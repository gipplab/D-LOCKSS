@startuml Message Flow Diagram

participant "Node A" as A
participant "GossipSub" as GS
participant "Node B" as B
participant "Node C" as C
participant "CRDT (shard)" as CRDT
participant "IPFS" as IPFS

== Cluster State Sync (per shard) ==
note over A, CRDT: Each shard has its own CRDT (dlockss-shard-<id>)
A -> CRDT: LogPin(pin) on shard's cluster
CRDT -> B: Sync (PubSub)
CRDT -> C: Sync (PubSub)
B -> B: LocalPinTracker sees new CID\n(allocation-aware: pin if we are in Allocations)
B -> IPFS: PinRecursive(ManifestCID)
C -> C: LocalPinTracker sees new CID
C -> IPFS: PinRecursive(ManifestCID)

== File Ingestion ==
A -> GS: IngestMessage(CBOR)\n{manifest_cid, shard_id, hint_size, sender_id, ts, nonce, sig}\n(topic: dlockss-creative-commons-shard-<id>)
GS -> B: Forward message
GS -> C: Forward message
B -> B: Add to knownFiles\nIf AmIResponsibleFor(PayloadCID): Pin to cluster, AnnouncePinned
C -> C: Add to knownFiles\nIf responsible: Pin to cluster, AnnouncePinned

== Replication Request ==
A -> GS: ReplicationRequest(CBOR)\n{manifest_cid, priority, deadline, sender_id, ts, nonce, sig} (shard topic)
GS -> B: Forward message
GS -> C: Forward message
B -> B: targetShard = targetShardForManifest(manifest, topicShard)
B -> B: If we have file: JoinShard(targetShard), EnsureClusterForShard,\nPin(targetShard), TriggerSync(targetShard)
alt B has file
    B -> CRDT: Pin(targetShard) via ClusterManager
    B -> B: TriggerSync(targetShard)
else B does not have file
    B -> IPFS: Fetch PinRecursive(manifestCID)
    B -> CRDT: Pin(targetShard)
    B -> B: TriggerSync(targetShard)
end
C -> C: Same logic (target shard = file's shard by PayloadCID)

== Custodial (Tourist) ==
note over A: Local ingest; we are NOT responsible.\nTarget shard = TargetShardForPayload(PayloadCID, depth)
A -> GS: JoinShard(targetShard)
A -> CRDT: EnsureClusterForShard, Pin(targetShard)
A -> GS: IngestMessage(CBOR) to target shard topic
GS -> C: Forward (nodes in target shard)
C -> C: If responsible: Pin to cluster, AnnouncePinned
note over A: We remain in target shard as tourist.\nReshard pass later may unpin if we leave.

== Rate Limiting ==
A -> GS: Message
GS -> B: Forward
B -> B: rateLimiter.Check(peer)
alt Rate limit OK
    B -> B: Process message
else Rate limit exceeded
    B -> B: Drop message, Increment messagesDropped
end

@enduml
