@startuml Shard Split Sequence

participant "ShardManager" as ShardMgr
participant "PubSub" as PubSub
participant "ClusterManager" as ClusterMgr
participant "StorageManager" as Storage
participant "CRDT" as CRDT
participant "IPFS" as IPFS

== Path 1: Split when current shard is overcrowded ==

ShardMgr -> ShardMgr: runPeerCountChecker()\n(ticker: rootPeerCheckInterval at root, ShardPeerCheckInterval otherwise)
ShardMgr -> ShardMgr: getShardPeerCount()\n(max(mesh+1, seen+1) for current shard)

alt peerCount > MaxPeersPerShard\nAND estimatedPeersAfterSplit >= minPerChild (MinPeersPerShard or minPeersPerChildAfterSplit)
    ShardMgr -> ShardMgr: splitShard()
    ShardMgr -> ShardMgr: currentShard = GetBinaryPrefix(peerID, depth+1)
    
    ShardMgr -> PubSub: JoinShard(newShard)\n(topic: dlockss-creative-commons-shard-<newShard>)
    
    ShardMgr -> ClusterMgr: JoinShard(ctx, newShard, nil)
    ClusterMgr -> CRDT: crdt.New(..., dlockss-shard-<newShard>)
    ClusterMgr -> ClusterMgr: NewLocalPinTracker, Start, subscribe to CRDT topic for TriggerSync
    
    ShardMgr -> ShardMgr: go: Sleep(migratePinsFlushDelay)\nMigratePins(oldShard, newShard)
    Note right of ClusterMgr: MigratePins: ListPins(old), for each pin belonging to newShard (by PayloadCID), Pin(newShard)
    
    ShardMgr -> ShardMgr: go: Sleep(ShardOverlapDuration)\nLeaveShard(oldShard)
    ShardMgr -> PubSub: LEAVE, cancel sub, Close topic (old shard)
    ShardMgr -> ClusterMgr: LeaveShard(oldShard)
    
    ShardMgr -> ShardMgr: go: Sleep(ReshardDelay)\nRunReshardPass(oldShard, newShard)
    ShardMgr -> Storage: GetKnownFiles().All()
    loop For each file
        ShardMgr -> ShardMgr: targetNew = GetHexBinaryPrefix(KeyToStableHex(payloadCID), newDepth)\ntargetOld = ... oldDepth
        alt Now responsible (targetNew == newShard) and IsPinned
            ShardMgr -> PubSub: Publish IngestMessage (new shard)
        else Was responsible, now not (targetNew != newShard)
            ShardMgr -> ClusterMgr: Unpin(ctx, oldShard, manifestCID)
            ShardMgr -> IPFS: UnpinRecursive\nStorage.UnpinFile
        end
    end
end

== Path 2: Discover and migrate into existing deeper shards (root only) ==

Note over ShardMgr: At root (currentShard == ""): runShardDiscovery()\nprobe deeper shards (JoinShardAsObserver), then move to deepest with peers.

ShardMgr -> ShardMgr: runShardDiscovery()\n(ticker: discoveryIntervalOnRoot at root, ShardDiscoveryInterval otherwise)
ShardMgr -> ShardMgr: checkAndMergeUpIfAlone()\nthen discoverAndMoveToDeeperShard()

alt At root AND deeper shard has >= minRequired peers
    ShardMgr -> ShardMgr: JoinShardAsObserver(deepestActiveShard)\nobserverProbeDuration, then JoinShard (promote to full)
    ShardMgr -> ShardMgr: currentShard = deepestActiveShard
    ShardMgr -> PubSub: JoinShard(newShard)
    ShardMgr -> ClusterMgr: JoinShard(ctx, newShard, nil)
    ShardMgr -> ShardMgr: MigratePins(oldShard, newShard)\nLeaveShard(oldShard) after ShardOverlapDuration\nRunReshardPass(oldShard, newShard)
end

== Path 3: Merge up when understaffed in deep shard ==

Note over ShardMgr: currentPeerCount < MinPeersPerShard\nparent has room, sibling empty or we're smaller/equal -> move to parent.

ShardMgr -> ShardMgr: checkAndMergeUpIfAlone()
alt len(currentShard) >= 2\nAND currentPeerCount < MinPeersPerShard\nAND parentPeerCount < MaxPeersPerShard\nAND (sibling empty OR we're smaller/equal)
    ShardMgr -> ShardMgr: currentShard = parentShard
    ShardMgr -> PubSub: JoinShard(parentShard)
    ShardMgr -> ClusterMgr: JoinShard(ctx, parentShard, nil)
    ShardMgr -> ShardMgr: MigratePins(oldShard, parentShard)\nLeaveShard(oldShard) after ShardOverlapDuration\nRunReshardPass(oldShard, parentShard)
end

@enduml
