@startuml Shard Split Sequence

participant "ShardManager" as ShardMgr
participant "PubSub" as PubSub
participant "StorageManager" as Storage
participant "ReplicationManager" as ReplMgr
participant "Old Shard Reader" as OldReader

ShardMgr -> ShardMgr: runPeerCountChecker()\n(periodic ticker every ShardPeerCheckInterval)
ShardMgr -> ShardMgr: getShardPeerCount()\n(topic.ListPeers() + 1)

alt peerCount > MaxPeersPerShard\nAND estimatedPeersAfterSplit >= MinPeersPerShard
    ShardMgr -> ShardMgr: splitShard()
    ShardMgr -> ShardMgr: Calculate new depth\ncurrentDepth + 1
    ShardMgr -> ShardMgr: Get peerIDHash at new depth
    ShardMgr -> ShardMgr: Update currentShard = peerIDHash
    
    Note over ShardMgr: Entering Overlap State
    
    ShardMgr -> PubSub: Join new shard topic
    ShardMgr -> ShardMgr: Keep old shard subscription active
    ShardMgr -> ShardMgr: Set overlap end time
    ShardMgr -> OldReader: Start readOldShard() goroutine
    
    Note over ShardMgr: Reshard Pass (Re-evaluate Responsibility)
    ShardMgr -> Storage: Walk known files
    loop For each file
        ShardMgr -> ShardMgr: Calculate new responsibility
        alt Moved ONTO shard
             ShardMgr -> PubSub: Publish IngestMessage (New Shard)
        end
    end
    
    Note over ShardMgr,OldReader: Overlap Period\n(Both subscriptions active)
    
    loop During Overlap Period
        OldReader -> PubSub: Read messages from old shard
        alt Message received
            OldReader -> ShardMgr: Process messages
            ShardMgr -> Storage: addKnownFile(hash)
            Note over ShardMgr: Added to known files, picked up by ReplMgr
        end
    end
    
    alt Overlap period expired
        ShardMgr -> PubSub: Cancel old shard subscription
        ShardMgr -> ShardMgr: Set inOverlap = false
        Note over ShardMgr: Overlap complete\nOnly new shard active
    end
    
    Note over ShardMgr: Responsibility changed
end

@enduml
